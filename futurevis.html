<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infographic: Future Vision</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="finalbg.png" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
        }
        .infographic-container {
            max-width: 1200px;
            margin: auto;
            background: #1f2937;
            border: 1px solid #374151;
        }
        #hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.2;
        }
        .header-content {
            position: relative;
            z-index: 1;
        }
        .title-line {
            height: 4px;
            background: linear-gradient(90deg, #10b981, #38bdf8, #818cf8);
            border-radius: 2px;
        }
        .category-card {
            background-color: #111827;
            border: 1px solid #374151;
        }
        .icon-bg {
            background-color: #1f2937;
        }
    </style>
</head>
<body class="antialiased p-4 sm:p-8">

    <div class="infographic-container p-6 sm:p-10 rounded-xl shadow-2xl">
        <div class="mb-8">
            <a href="mtlabs.html" class="inline-flex items-center text-sm font-semibold text-gray-300 hover:text-white transition px-4 py-2 rounded-lg bg-gray-800 hover:bg-gray-700">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"/></svg>
                Back to MTLabs
            </a>
        </div>

        <header class="text-center mb-16 relative overflow-hidden rounded-lg p-8">
            <canvas id="hero-canvas"></canvas>
            <div class="header-content">
                <h1 class="text-4xl sm:text-5xl font-black text-white leading-tight">Future Vision</h1>
                <p class="text-lg text-teal-300 font-medium mt-2">Engineering the Next Generation of Security</p>
                <div class="title-line w-24 mx-auto mt-4"></div>
            </div>
        </header>
        
        <section class="mb-16 text-center">
             <h2 class="text-3xl font-bold text-white mb-4">Beyond Migration: The Next Frontier</h2>
             <p class="max-w-3xl mx-auto text-lg text-gray-300">
                 The NIST PQC transition is just the beginning. At MTLABS, we are architecting a future where security is not just resistant to attack, but is intelligent, adaptable, and woven into the fabric of quantum technology itself.
             </p>
        </section>

        <div class="space-y-12">
            <div class="category-card p-6 sm:p-8 rounded-lg">
                <div class="flex flex-col sm:flex-row items-start gap-6">
                    <div class="icon-bg flex-shrink-0 w-16 h-16 rounded-full flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#818cf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1v22M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg></div>
                    <div>
                        <h2 class="text-2xl font-bold text-white">Dynamic Crypto-Agility</h2>
                        <p class="mt-2 text-sm text-blue-300 font-medium">ANALOGY: A PLUGGABLE SECURITY ENGINE</p>
                        <p class="mt-3 text-gray-300">Imagine your car's engine could be swapped out in seconds. Crypto-agility is the same principle for security, allowing systems to adapt to new threats without a complete overhaul. We are developing orchestration platforms to manage cryptographic policies, allowing organizations to update algorithms across their entire infrastructure from a central point.</p>
                    </div>
                </div>
            </div>

            <div class="category-card p-6 sm:p-8 rounded-lg">
                <div class="flex flex-col sm:flex-row items-start gap-6">
                    <div class="icon-bg flex-shrink-0 w-16 h-16 rounded-full flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></div>
                    <div>
                        <h2 class="text-2xl font-bold text-white">Quantum-Native Security</h2>
                        <p class="mt-2 text-sm text-emerald-300 font-medium">ANALOGY: USING QUANTUM PHYSICS AS THE LOCK</p>
                        <p class="mt-3 text-gray-300">While PQC uses math that's hard for quantum computers, quantum-native security uses the laws of physics themselves. We are researching hybrid models that combine the proven security of Quantum Key Distribution (QKD) with the practicality of PQC algorithms, creating a multi-layered defense for ultra-secure communications.</p>
                    </div>
                </div>
            </div>
            
            <div class="category-card p-6 sm:p-8 rounded-lg">
                <div class="flex flex-col sm:flex-row items-start gap-6">
                    <div class="icon-bg flex-shrink-0 w-16 h-16 rounded-full flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#38bdf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"/><rect x="4" y="4" width="16" height="16" rx="2"/><path d="M12 12h.01"/><path d="M16 12h.01"/><path d="M12 16h.01"/><path d="M16 16h.01"/><path d="M8 12h.01"/><path d="M8 16h.01"/></svg></div>
                    <div>
                        <h2 class="text-2xl font-bold text-white">AI-Driven Cryptanalysis</h2>
                        <p class="mt-2 text-sm text-sky-300 font-medium">ANALOGY: AN AI-POWERED CODEBREAKER</p>
                        <p class="mt-3 text-gray-300">Artificial intelligence is a powerful tool for finding complex patterns. We are building AI models to automate the security auditing of cryptographic implementations. This allows us to find and fix potential flaws faster and more effectively than manual analysis alone, ensuring our solutions are robust against both current and future threats.</p>
                    </div>
                </div>
            </div>
        </div>

        <footer class="text-center mt-16 pt-8 border-t border-gray-700">
            <p class="text-lg font-semibold text-white">Our vision is to build a future that is not just quantum-resistant, but quantum-ready.</p>
            <div class="mt-6">
                <a href="index.html" class="text-xl tracking-wider"><span class="font-bold text-white">MOONTRACE</span><span class="font-normal text-red-500">|</span><span class="font-normal text-gray-400">ENGINEERING</span></a>
            </div>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Animation
            const heroScene = new THREE.Scene();
            const heroCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const heroRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('hero-canvas'), alpha: true, antialias: true });
            heroRenderer.setSize(window.innerWidth, window.innerHeight);
            const mouse = new THREE.Vector2();
            window.addEventListener('mousemove', (event) => { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; });
            const heroParticleCount = 500;
            const heroParticles = new THREE.BufferGeometry();
            const heroPositions = new Float32Array(heroParticleCount * 3);
            const heroParticleData = [];
            for (let i = 0; i < heroParticleCount; i++) {
                const x = (Math.random() - 0.5) * 20; const y = (Math.random() - 0.5) * 20; const z = (Math.random() - 0.5) * 20;
                heroPositions[i * 3] = x; heroPositions[i * 3 + 1] = y; heroPositions[i * 3 + 2] = z;
                heroParticleData.push({ originalX: x, originalY: y, originalZ: z, velocityX: (Math.random() - 0.5) * 0.01, velocityY: (Math.random() - 0.5) * 0.01, velocityZ: (Math.random() - 0.5) * 0.01 });
            }
            heroParticles.setAttribute('position', new THREE.BufferAttribute(heroPositions, 3));
            const heroParticleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
            const heroParticleSystem = new THREE.Points(heroParticles, heroParticleMaterial);
            heroScene.add(heroParticleSystem);
            const heroLineMaterial = new THREE.LineBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.08 });
            const heroLineGeometry = new THREE.BufferGeometry();
            const heroLinePositions = new Float32Array(heroParticleCount * heroParticleCount * 3);
            heroLineGeometry.setAttribute('position', new THREE.BufferAttribute(heroLinePositions, 3));
            const heroLines = new THREE.LineSegments(heroLineGeometry, heroLineMaterial);
            heroScene.add(heroLines);
            heroCamera.position.z = 15;
            let heroTime = 0;
            function animateHero() {
                requestAnimationFrame(animateHero);
                heroTime += 0.005;
                const posArray = heroParticleSystem.geometry.attributes.position.array;
                const linePosArray = heroLines.geometry.attributes.position.array;
                let lineIndex = 0;
                const mouse3D = new THREE.Vector3(mouse.x * 10, mouse.y * 10, 0);
                for (let i = 0; i < heroParticleCount; i++) {
                    const data = heroParticleData[i];
                    const particlePos = new THREE.Vector3(posArray[i*3], posArray[i*3+1], posArray[i*3+2]);
                    const distanceToMouse = particlePos.distanceTo(mouse3D);
                    const pushStrength = Math.max(0, 1 - distanceToMouse / 5);
                    const pushVector = particlePos.clone().sub(mouse3D).normalize().multiplyScalar(pushStrength * 0.1);
                    posArray[i * 3] += Math.sin(heroTime + data.originalX) * 0.001 + data.velocityX + pushVector.x;
                    posArray[i * 3 + 1] += Math.cos(heroTime + data.originalY) * 0.001 + data.velocityY + pushVector.y;
                    posArray[i * 3 + 2] += data.velocityZ + pushVector.z;
                    if (posArray[i * 3] > 10 || posArray[i * 3] < -10) data.velocityX *= -1;
                    if (posArray[i * 3 + 1] > 10 || posArray[i * 3 + 1] < -10) data.velocityY *= -1;
                    if (posArray[i * 3 + 2] > 10 || posArray[i * 3 + 2] < -10) data.velocityZ *= -1;
                    for (let j = i + 1; j < heroParticleCount; j++) {
                        const dx = posArray[i * 3] - posArray[j * 3]; const dy = posArray[i * 3 + 1] - posArray[j * 3 + 1]; const dz = posArray[i * 3 + 2] - posArray[j * 3 + 2];
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        if (distance < 1.8) {
                            linePosArray[lineIndex++] = posArray[i * 3]; linePosArray[lineIndex++] = posArray[i * 3 + 1]; linePosArray[lineIndex++] = posArray[i * 3 + 2];
                            linePosArray[lineIndex++] = posArray[j * 3]; linePosArray[lineIndex++] = posArray[j * 3 + 1]; linePosArray[lineIndex++] = posArray[j * 3 + 2];
                        }
                    }
                }
                heroLines.geometry.setDrawRange(0, lineIndex / 3);
                heroLines.geometry.attributes.position.needsUpdate = true;
                heroParticleSystem.geometry.attributes.position.needsUpdate = true;
                heroScene.rotation.y += 0.0001; heroScene.rotation.x += 0.0001;
                heroRenderer.render(heroScene, heroCamera);
            }
            animateHero();
            window.addEventListener('resize', () => { heroCamera.aspect = window.innerWidth / window.innerHeight; heroCamera.updateProjectionMatrix(); heroRenderer.setSize(window.innerWidth, window.innerHeight); });
        });
    </script>
</body>
</html>
