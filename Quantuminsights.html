<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infographic: Interactive Quantum Insights</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="finalbg.png" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #d1d5db;
        }
        .infographic-container {
            max-width: 1200px;
            margin: auto;
            background: #1f2937;
            border: 1px solid #374151;
        }
        #hero-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.2;
        }
        .header-content {
            position: relative;
            z-index: 1;
        }
        .title-line {
            height: 4px;
            background: linear-gradient(90deg, #38bdf8, #818cf8, #c084fc);
            border-radius: 2px;
        }
        .category-card {
            background-color: #111827;
            border: 1px solid #374151;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5);
        }
        .icon-bg {
            background-color: #1f2937;
        }
    </style>
</head>
<body class="antialiased p-4 sm:p-8">

    <div class="infographic-container p-6 sm:p-10 rounded-xl shadow-2xl">

        <div class="mb-8">
            <a href="mtlabs.html" class="inline-flex items-center text-sm font-semibold text-gray-300 hover:text-white transition px-4 py-2 rounded-lg bg-gray-800 hover:bg-gray-700">
                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"/></svg>
                Back to MTLabs
            </a>
        </div>

        <header class="text-center mb-16 relative overflow-hidden rounded-lg p-8">
            <canvas id="hero-canvas"></canvas>
            <div class="header-content">
                <h1 class="text-4xl sm:text-5xl font-black text-white leading-tight">Quantum Insights</h1>
                <p class="text-lg text-blue-300 font-medium mt-2">An Interactive Guide to the NIST PQC Finalists</p>
                <div class="title-line w-24 mx-auto mt-4"></div>
                <p class="mt-6 max-w-3xl mx-auto text-base sm:text-lg">
                    Quantum computers threaten to break the cryptography that protects our digital world. The National Institute of Standards and Technology (NIST) ran a multi-year competition to find new, quantum-resistant algorithms. Here's an interactive look at the winning categories.
                </p>
            </div>
        </header>

        <div class="space-y-10">
            <div class="category-card p-6 sm:p-8 rounded-lg">
                <div class="flex flex-col sm:flex-row items-start gap-6">
                    <div class="icon-bg flex-shrink-0 w-16 h-16 rounded-full flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#c084fc" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16v16H4zM4 10h16M10 4v16"/></svg></div>
                    <div>
                        <h2 class="text-2xl font-bold text-white">Lattice-Based Cryptography</h2>
                        <p class="mt-2 text-sm text-purple-300 font-medium">ANALOGY: A MULTI-DIMENSIONAL MAZE</p>
                        <p class="mt-3 text-gray-300">Imagine a vast, complex grid (a lattice). Finding a specific, hidden point near a known location is a computationally hard problem for computers—especially quantum ones—without a secret "map." Our keys act as that secret map.</p>
                        <div class="mt-4 border-t border-gray-700 pt-4 space-y-2 text-sm">
                            <p><strong>NIST Standardized:</strong> CRYSTALS-Kyber (KEM), CRYSTALS-Dilithium (Signature), FALCON (Signature).</p>
                            <p><strong>Characteristics:</strong> Strong balance of security, key size, and performance. Kyber, in particular, has emerged as a leading choice due to its efficiency.</p>
                            <p><strong>Best For:</strong> General-purpose encryption (TLS), software updates, and protecting data at rest. It's the workhorse of the PQC transition.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="category-card p-6 sm:p-8 rounded-lg">
                <div class="flex flex-col sm:flex-row items-start gap-6">
                    <div class="icon-bg flex-shrink-0 w-16 h-16 rounded-full flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#818cf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><path d="M12 11h4"/><path d="M12 16h4"/><path d="M8 11h.01"/><path d="M8 16h.01"/><rect x="8" y="4" width="8" height="4" rx="1"/></svg></div>
                    <div>
                        <h2 class="text-2xl font-bold text-white">Hash-Based Cryptography</h2>
                        <p class="mt-2 text-sm text-blue-300 font-medium">ANALOGY: A DIGITAL FINGERPRINT</p>
                        <p class="mt-3 text-gray-300">This method relies on cryptographic hash functions, which are like one-way trapdoors. It's easy to create a unique "fingerprint" from data, but impossible to recreate the data from the fingerprint. Its security is well-understood and relies on minimal assumptions.</p>
                        <div class="mt-4 border-t border-gray-700 pt-4 space-y-2 text-sm">
                            <p><strong>NIST Standardized:</strong> SPHINCS+ (Signature).</p>
                            <p><strong>Characteristics:</strong> Highly conservative and secure, but produces larger signatures and requires careful state management to avoid key reuse.</p>
                            <p><strong>Best For:</strong> High-assurance software signing (firmware updates, code signing) where trust is paramount.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="category-card p-6 sm:p-8 rounded-lg">
                <div class="flex flex-col sm:flex-row items-start gap-6">
                    <div class="icon-bg flex-shrink-0 w-16 h-16 rounded-full flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#38bdf8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></div>
                    <div>
                        <h2 class="text-2xl font-bold text-white">Code-Based Cryptography</h2>
                        <p class="mt-2 text-sm text-blue-400 font-medium">ANALOGY: FINDING A NEEDLE IN A HAYSTACK</p>
                        <p class="mt-3 text-gray-300">Based on the difficulty of decoding a random-looking linear code. Imagine receiving a message intentionally garbled with errors. Without the secret "decoder ring" (the private key), correcting the errors and reading the message is an incredibly hard problem.</p>
                        <div class="mt-4 border-t border-gray-700 pt-4 space-y-2 text-sm">
                             <p><strong>NIST Candidates:</strong> Classic McEliece, BIKE, HQC.</p>
                             <p><strong>Characteristics:</strong> Very old and trusted, but has very large public key sizes, making it a niche choice.</p>
                             <p><strong>Best For:</strong> Scenarios where key size is not a constraint but long-term security is required (archival, VPNs).</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="text-center mt-16 pt-8 border-t border-gray-700">
            <p class="text-lg font-semibold text-white">The Quantum Era is Approaching.</p>
            <p class="mt-2 text-gray-400">At MTLABS, we are building the tools to make this transition secure and seamless.</p>
            <div class="mt-6">
                <a href="index.html" class="text-xl tracking-wider"><span class="font-bold text-white">MOONTRACE</span><span class="font-normal text-red-500">|</span><span class="font-normal text-gray-400">ENGINEERING</span></a>
            </div>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const heroScene = new THREE.Scene();
            const heroCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const heroRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('hero-canvas'), alpha: true, antialias: true });
            heroRenderer.setSize(window.innerWidth, window.innerHeight);
            const mouse = new THREE.Vector2();
            window.addEventListener('mousemove', (event) => { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; });
            const heroParticleCount = 500;
            const heroParticles = new THREE.BufferGeometry();
            const heroPositions = new Float32Array(heroParticleCount * 3);
            const heroParticleData = [];
            for (let i = 0; i < heroParticleCount; i++) {
                const x = (Math.random() - 0.5) * 20; const y = (Math.random() - 0.5) * 20; const z = (Math.random() - 0.5) * 20;
                heroPositions[i * 3] = x; heroPositions[i * 3 + 1] = y; heroPositions[i * 3 + 2] = z;
                heroParticleData.push({ originalX: x, originalY: y, originalZ: z, velocityX: (Math.random() - 0.5) * 0.01, velocityY: (Math.random() - 0.5) * 0.01, velocityZ: (Math.random() - 0.5) * 0.01 });
            }
            heroParticles.setAttribute('position', new THREE.BufferAttribute(heroPositions, 3));
            const heroParticleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
            const heroParticleSystem = new THREE.Points(heroParticles, heroParticleMaterial);
            heroScene.add(heroParticleSystem);
            const heroLineMaterial = new THREE.LineBasicMaterial({ color: 0x87CEEB, transparent: true, opacity: 0.08 });
            const heroLineGeometry = new THREE.BufferGeometry();
            const heroLinePositions = new Float32Array(heroParticleCount * heroParticleCount * 3);
            heroLineGeometry.setAttribute('position', new THREE.BufferAttribute(heroLinePositions, 3));
            const heroLines = new THREE.LineSegments(heroLineGeometry, heroLineMaterial);
            heroScene.add(heroLines);
            heroCamera.position.z = 15;
            let heroTime = 0;
            function animateHero() {
                requestAnimationFrame(animateHero);
                heroTime += 0.005;
                const posArray = heroParticleSystem.geometry.attributes.position.array;
                const linePosArray = heroLines.geometry.attributes.position.array;
                let lineIndex = 0;
                const mouse3D = new THREE.Vector3(mouse.x * 10, mouse.y * 10, 0);
                for (let i = 0; i < heroParticleCount; i++) {
                    const data = heroParticleData[i];
                    const particlePos = new THREE.Vector3(posArray[i*3], posArray[i*3+1], posArray[i*3+2]);
                    const distanceToMouse = particlePos.distanceTo(mouse3D);
                    const pushStrength = Math.max(0, 1 - distanceToMouse / 5);
                    const pushVector = particlePos.clone().sub(mouse3D).normalize().multiplyScalar(pushStrength * 0.1);
                    posArray[i * 3] += Math.sin(heroTime + data.originalX) * 0.001 + data.velocityX + pushVector.x;
                    posArray[i * 3 + 1] += Math.cos(heroTime + data.originalY) * 0.001 + data.velocityY + pushVector.y;
                    posArray[i * 3 + 2] += data.velocityZ + pushVector.z;
                    if (posArray[i * 3] > 10 || posArray[i * 3] < -10) data.velocityX *= -1;
                    if (posArray[i * 3 + 1] > 10 || posArray[i * 3 + 1] < -10) data.velocityY *= -1;
                    if (posArray[i * 3 + 2] > 10 || posArray[i * 3 + 2] < -10) data.velocityZ *= -1;
                    for (let j = i + 1; j < heroParticleCount; j++) {
                        const dx = posArray[i * 3] - posArray[j * 3]; const dy = posArray[i * 3 + 1] - posArray[j * 3 + 1]; const dz = posArray[i * 3 + 2] - posArray[j * 3 + 2];
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        if (distance < 1.8) {
                            linePosArray[lineIndex++] = posArray[i * 3]; linePosArray[lineIndex++] = posArray[i * 3 + 1]; linePosArray[lineIndex++] = posArray[i * 3 + 2];
                            linePosArray[lineIndex++] = posArray[j * 3]; linePosArray[lineIndex++] = posArray[j * 3 + 1]; linePosArray[lineIndex++] = posArray[j * 3 + 2];
                        }
                    }
                }
                heroLines.geometry.setDrawRange(0, lineIndex / 3);
                heroLines.geometry.attributes.position.needsUpdate = true;
                heroParticleSystem.geometry.attributes.position.needsUpdate = true;
                heroScene.rotation.y += 0.0001; heroScene.rotation.x += 0.0001;
                heroRenderer.render(heroScene, heroCamera);
            }
            animateHero();
            window.addEventListener('resize', () => { heroCamera.aspect = window.innerWidth / window.innerHeight; heroCamera.updateProjectionMatrix(); heroRenderer.setSize(window.innerWidth, window.innerHeight); });
        });
    </script>
</body>
</html>
